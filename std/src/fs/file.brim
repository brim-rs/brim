use { HANDLE, DWORD, OVERLAPPED, OVERLAPPED_0, OVERLAPPED_0_0 } from "../os/windows.brim"
use { IoError } from "../io/error.brim";

pub type HandleTy = match @os() {
    "windows" => HANDLE,
    "linux" => i32,
    "macos" => i32,
    else => i32
};

pub struct Handle {
    inner: HandleTy

    fn write(self: &Handle, data: &[u8], offset: u64?) usize!IoError {
        let overlapped = if offset {
            return OVERLAPPED {
                .Internal = @cast(0, usize),
                .InternalHigh = @cast(0, usize),
                .Anonymous = OVERLAPPED_0 {
                    .Anonymous = OVERLAPPED_0_0 {
                        .Offset = @cast(offset?, DWORD),
                        .OffsetHigh = @cast(32, DWORD),
                    },
                },
                .hEvent = @none(),
            }
        } else {
            // Write data at current position
        }
    }
}

pub struct File {
    handle: Handle,

    fn write(self: &File, data: &[u8]) usize!IoError {
        return self.handle.write(data, @none());
    }
}
